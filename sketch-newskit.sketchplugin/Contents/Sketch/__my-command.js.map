{"version":3,"sources":["webpack://exports/webpack/bootstrap","webpack://exports//Users/luke/node_modules/@skpm/fs/index.js","webpack://exports//Users/luke/node_modules/@skpm/fs/utils.js","webpack://exports//Users/luke/node_modules/@skpm/path/index.js","webpack://exports//Users/luke/node_modules/@skpm/path/sketch-specifics.js","webpack://exports/./src/my-command.js","webpack://exports/external \"buffer\"","webpack://exports/external \"os\"","webpack://exports/external \"sketch\"","webpack://exports/external \"sketch/dom\"","webpack://exports/external \"sketch/ui\"","webpack://exports/external \"util\""],"names":["sketch","require","Document","document","getSelectedDocument","fs","path","home","homedir","exportPath","texts","paints","shadows","blurs","output","getSharedStyles","type","myStyles","version","styles","MSDocument","currentDocument","documentData","layerStyles","objects","layerTextStyles","allLayerStyles","allTextStyles","sortByName","NSSortDescriptor","sortDescriptorWithKey_ascending","sortedArrayUsingDescriptors","forEach","style","push","colourPalette","colourStyles","filter","name","includes","value","split","length","fills","fill","fillType","MSColorToRGBA","color","parseGradient","gradient","existsSync","mkdirSync","writeFileSync","JSON","stringify","err","console","error","regex","RegExp","themeColours","outputThemeColours","getPrimitiveFromColor","c","prim","getKeyByValue","object","Object","keys","find","key","textStyles","getSharedTextStyleWithID","objectID","alignment","o","inp","fontStyle","textStyle","fontPostscriptName","replace","n","pop","join","fontSize","fontName","family","fontFamily","lineHeight","unit","letterSpacing","kerning","paragraphSpacing","shadowStyles","effects","shadow","e","r","red","g","green","b","blue","a","alpha","blendMode","visible","offset","x","offsetX","y","offsetY","radius","blurRadius","blurStyles","blur","isEnabled","warn","str","UI","getInputFromUser","description","initialValue","INPUT_TYPE","string","numberOfLines","message","angle","angleBetween","from","to","gradientType","stops","stop","position","toFixed","Math","round","p1","p2","angleDeg","atan2","PI"],"mappings":";;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,YAAY,mBAAO,CAAC,wDAAS;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AClbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,gFAAoB;;AAElD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,8BAA8B;AACpE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,yBAAyB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,WAAW;AACX;AACA,qCAAqC;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA,gDAAgD;AAChD;AACA,WAAW;AACX;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KA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","file":"__my-command.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/my-command.js\");\n","// TODO: async. Should probably be done with NSFileHandle and some notifications\n// TODO: file descriptor. Needs to be done with NSFileHandle\nvar Buffer = require(\"buffer\").Buffer;\nvar utils = require(\"./utils\");\nvar parseStat = utils.parseStat;\nvar fsError = utils.fsError;\nvar fsErrorForPath = utils.fsErrorForPath;\nvar encodingFromOptions = utils.encodingFromOptions;\nvar NOT_IMPLEMENTED = utils.NOT_IMPLEMENTED;\n\nmodule.exports.constants = {\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1\n};\n\nmodule.exports.access = NOT_IMPLEMENTED(\"access\");\n\nmodule.exports.accessSync = function(path, mode) {\n  mode = mode | 0;\n  var fileManager = NSFileManager.defaultManager();\n\n  switch (mode) {\n    case 0:\n      canAccess = module.exports.existsSync(path);\n      break;\n    case 1:\n      canAccess = Boolean(Number(fileManager.isExecutableFileAtPath(path)));\n      break;\n    case 2:\n      canAccess = Boolean(Number(fileManager.isWritableFileAtPath(path)));\n      break;\n    case 3:\n      canAccess =\n        Boolean(Number(fileManager.isExecutableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isWritableFileAtPath(path)));\n      break;\n    case 4:\n      canAccess = Boolean(Number(fileManager.isReadableFileAtPath(path)));\n      break;\n    case 5:\n      canAccess =\n        Boolean(Number(fileManager.isReadableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isExecutableFileAtPath(path)));\n      break;\n    case 6:\n      canAccess =\n        Boolean(Number(fileManager.isReadableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isWritableFileAtPath(path)));\n      break;\n    case 7:\n      canAccess =\n        Boolean(Number(fileManager.isReadableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isWritableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isExecutableFileAtPath(path)));\n      break;\n  }\n\n  if (!canAccess) {\n    throw new Error(\"Can't access \" + String(path));\n  }\n};\n\nmodule.exports.appendFile = NOT_IMPLEMENTED(\"appendFile\");\n\nmodule.exports.appendFileSync = function(file, data, options) {\n  if (!module.exports.existsSync(file)) {\n    return module.exports.writeFileSync(file, data, options);\n  }\n\n  var handle = NSFileHandle.fileHandleForWritingAtPath(file);\n  handle.seekToEndOfFile();\n\n  var encoding = encodingFromOptions(options, \"utf8\");\n\n  var nsdata = Buffer.from(\n    data,\n    encoding === \"NSData\" || encoding === \"buffer\" ? undefined : encoding\n  ).toNSData();\n\n  handle.writeData(nsdata);\n};\n\nmodule.exports.chmod = NOT_IMPLEMENTED(\"chmod\");\n\nmodule.exports.chmodSync = function(path, mode) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.setAttributes_ofItemAtPath_error(\n    {\n      NSFilePosixPermissions: mode\n    },\n    path,\n    err\n  );\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n};\n\nmodule.exports.chown = NOT_IMPLEMENTED(\"chown\");\nmodule.exports.chownSync = NOT_IMPLEMENTED(\"chownSync\");\n\nmodule.exports.close = NOT_IMPLEMENTED(\"close\");\nmodule.exports.closeSync = NOT_IMPLEMENTED(\"closeSync\");\n\nmodule.exports.copyFile = NOT_IMPLEMENTED(\"copyFile\");\n\nmodule.exports.copyFileSync = function(path, dest, flags) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.copyItemAtPath_toPath_error(path, dest, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, false, err.value());\n  }\n};\n\nmodule.exports.createReadStream = NOT_IMPLEMENTED(\"createReadStream\");\nmodule.exports.createWriteStream = NOT_IMPLEMENTED(\"createWriteStream\");\n\nmodule.exports.exists = NOT_IMPLEMENTED(\"exists\");\n\nmodule.exports.existsSync = function(path) {\n  var fileManager = NSFileManager.defaultManager();\n  return Boolean(Number(fileManager.fileExistsAtPath(path)));\n};\n\nmodule.exports.fchmod = NOT_IMPLEMENTED(\"fchmod\");\nmodule.exports.fchmodSync = NOT_IMPLEMENTED(\"fchmodSync\");\nmodule.exports.fchown = NOT_IMPLEMENTED(\"fchown\");\nmodule.exports.fchownSync = NOT_IMPLEMENTED(\"fchownSync\");\nmodule.exports.fdatasync = NOT_IMPLEMENTED(\"fdatasync\");\nmodule.exports.fdatasyncSync = NOT_IMPLEMENTED(\"fdatasyncSync\");\nmodule.exports.fstat = NOT_IMPLEMENTED(\"fstat\");\nmodule.exports.fstatSync = NOT_IMPLEMENTED(\"fstatSync\");\nmodule.exports.fsync = NOT_IMPLEMENTED(\"fsync\");\nmodule.exports.fsyncSync = NOT_IMPLEMENTED(\"fsyncSync\");\nmodule.exports.ftruncate = NOT_IMPLEMENTED(\"ftruncate\");\nmodule.exports.ftruncateSync = NOT_IMPLEMENTED(\"ftruncateSync\");\nmodule.exports.futimes = NOT_IMPLEMENTED(\"futimes\");\nmodule.exports.futimesSync = NOT_IMPLEMENTED(\"futimesSync\");\n\nmodule.exports.lchmod = NOT_IMPLEMENTED(\"lchmod\");\nmodule.exports.lchmodSync = NOT_IMPLEMENTED(\"lchmodSync\");\nmodule.exports.lchown = NOT_IMPLEMENTED(\"lchown\");\nmodule.exports.lchownSync = NOT_IMPLEMENTED(\"lchownSync\");\n\nmodule.exports.link = NOT_IMPLEMENTED(\"link\");\n\nmodule.exports.linkSync = function(existingPath, newPath) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.linkItemAtPath_toPath_error(existingPath, newPath, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(existingPath, undefined, err.value());\n  }\n};\n\nmodule.exports.lstat = NOT_IMPLEMENTED(\"lstat\");\n\nmodule.exports.lstatSync = function(path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.attributesOfItemAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n\n  return parseStat(result);\n};\n\nmodule.exports.mkdir = NOT_IMPLEMENTED(\"mkdir\");\n\nmodule.exports.mkdirSync = function(path, options) {\n  var mode = 0o777;\n  var recursive = false;\n  if (options && options.mode) {\n    mode = options.mode;\n  }\n  if (options && options.recursive) {\n    recursive = options.recursive;\n  }\n  if (typeof options === \"number\") {\n    mode = options;\n  }\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.createDirectoryAtPath_withIntermediateDirectories_attributes_error(\n    path,\n    recursive,\n    {\n      NSFilePosixPermissions: mode\n    },\n    err\n  );\n\n  if (err.value() !== null) {\n    throw new Error(err.value());\n  }\n};\n\nmodule.exports.mkdtemp = NOT_IMPLEMENTED(\"mkdtemp\");\n\nmodule.exports.mkdtempSync = function(path) {\n  function makeid() {\n    var text = \"\";\n    var possible =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n    for (var i = 0; i < 6; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n  var tempPath = path + makeid();\n  module.exports.mkdirSync(tempPath);\n  return tempPath;\n};\n\nmodule.exports.open = NOT_IMPLEMENTED(\"open\");\nmodule.exports.openSync = NOT_IMPLEMENTED(\"openSync\");\n\nmodule.exports.read = NOT_IMPLEMENTED(\"read\");\n\nmodule.exports.readdir = NOT_IMPLEMENTED(\"readdir\");\n\nmodule.exports.readdirSync = function(path, options) {\n  var encoding = encodingFromOptions(options, \"utf8\");\n  var fileManager = NSFileManager.defaultManager();\n  var paths = fileManager.subpathsAtPath(path);\n  var arr = [];\n  for (var i = 0; i < paths.length; i++) {\n    var pathName = paths[i];\n    arr.push(encoding === \"buffer\" ? Buffer.from(pathName) : String(pathName));\n  }\n  return arr;\n};\n\nmodule.exports.readFile = NOT_IMPLEMENTED(\"readFile\");\n\nmodule.exports.readFileSync = function(path, options) {\n  var encoding = encodingFromOptions(options, \"buffer\");\n  var fileManager = NSFileManager.defaultManager();\n  var data = fileManager.contentsAtPath(path);\n  if (!data) {\n    throw fsErrorForPath(path, false);\n  }\n\n  var buffer = Buffer.from(data);\n\n  if (encoding === \"buffer\") {\n    return buffer;\n  } else if (encoding === \"NSData\") {\n    return buffer.toNSData();\n  } else {\n    return buffer.toString(encoding);\n  }\n};\n\nmodule.exports.readlink = NOT_IMPLEMENTED(\"readlink\");\n\nmodule.exports.readlinkSync = function(path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.destinationOfSymbolicLinkAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n\n  return String(result);\n};\n\nmodule.exports.readSync = NOT_IMPLEMENTED(\"readSync\");\n\nmodule.exports.realpath = NOT_IMPLEMENTED(\"realpath\");\nmodule.exports.realpath.native = NOT_IMPLEMENTED(\"realpath.native\");\n\nmodule.exports.realpathSync = function(path) {\n  return String(NSString.stringWithString(path).stringByResolvingSymlinksInPath());\n};\n\nmodule.exports.realpathSync.native = NOT_IMPLEMENTED(\"realpathSync.native\");\n\nmodule.exports.rename = NOT_IMPLEMENTED(\"rename\");\n\nmodule.exports.renameSync = function(oldPath, newPath) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.moveItemAtPath_toPath_error(oldPath, newPath, err);\n\n  var error = err.value();\n\n  if (error !== null) {\n    // if there is already a file, we need to overwrite it\n    if (\n      String(error.domain()) === \"NSCocoaErrorDomain\" &&\n      Number(error.code()) === 516\n    ) {\n      var err2 = MOPointer.alloc().init();\n      fileManager.replaceItemAtURL_withItemAtURL_backupItemName_options_resultingItemURL_error(\n        NSURL.fileURLWithPath(newPath),\n        NSURL.fileURLWithPath(oldPath),\n        null,\n        NSFileManagerItemReplacementUsingNewMetadataOnly,\n        null,\n        err2\n      );\n      if (err2.value() !== null) {\n        throw fsErrorForPath(oldPath, undefined, err2.value());\n      }\n    } else {\n      throw fsErrorForPath(oldPath, undefined, error);\n    }\n  }\n};\n\nmodule.exports.rmdir = NOT_IMPLEMENTED(\"rmdir\");\n\nmodule.exports.rmdirSync = function(path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var isDirectory = module.exports.lstatSync(path).isDirectory();\n  if (!isDirectory) {\n    throw fsError(\"ENOTDIR\", {\n      path: path,\n      syscall: \"rmdir\"\n    });\n  }\n  fileManager.removeItemAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, true, err.value(), \"rmdir\");\n  }\n};\n\nmodule.exports.stat = NOT_IMPLEMENTED(\"stat\");\n\n// the only difference with lstat is that we resolve symlinks\n//\n// > lstat() is identical to stat(), except that if pathname is a symbolic\n// > link, then it returns information about the link itself, not the file\n// > that it refers to.\n// http://man7.org/linux/man-pages/man2/lstat.2.html\nmodule.exports.statSync = function(path) {\n  return module.exports.lstatSync(module.exports.realpathSync(path));\n};\n\nmodule.exports.symlink = NOT_IMPLEMENTED(\"symlink\");\n\nmodule.exports.symlinkSync = function(target, path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.createSymbolicLinkAtPath_withDestinationPath_error(\n    path,\n    target,\n    err\n  );\n\n  if (err.value() !== null) {\n    throw new Error(err.value());\n  }\n};\n\nmodule.exports.truncate = NOT_IMPLEMENTED(\"truncate\");\n\nmodule.exports.truncateSync = function(path, len) {\n  var hFile = NSFileHandle.fileHandleForUpdatingAtPath(sFilePath);\n  hFile.truncateFileAtOffset(len || 0);\n  hFile.closeFile();\n};\n\nmodule.exports.unlink = NOT_IMPLEMENTED(\"unlink\");\n\nmodule.exports.unlinkSync = function(path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var isDirectory = module.exports.lstatSync(path).isDirectory();\n  if (isDirectory) {\n    throw fsError(\"EPERM\", {\n      path: path,\n      syscall: \"unlink\"\n    });\n  }\n  var result = fileManager.removeItemAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, false, err.value());\n  }\n};\n\nmodule.exports.unwatchFile = NOT_IMPLEMENTED(\"unwatchFile\");\n\nmodule.exports.utimes = NOT_IMPLEMENTED(\"utimes\");\n\nmodule.exports.utimesSync = function(path, aTime, mTime) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.setAttributes_ofItemAtPath_error(\n    {\n      NSFileModificationDate: aTime\n    },\n    path,\n    err\n  );\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n};\n\nmodule.exports.watch = NOT_IMPLEMENTED(\"watch\");\nmodule.exports.watchFile = NOT_IMPLEMENTED(\"watchFile\");\n\nmodule.exports.write = NOT_IMPLEMENTED(\"write\");\n\nmodule.exports.writeFile = NOT_IMPLEMENTED(\"writeFile\");\n\nmodule.exports.writeFileSync = function(path, data, options) {\n  var encoding = encodingFromOptions(options, \"utf8\");\n\n  var nsdata = Buffer.from(\n    data,\n    encoding === \"NSData\" || encoding === \"buffer\" ? undefined : encoding\n  ).toNSData();\n\n  nsdata.writeToFile_atomically(path, true);\n};\n\nmodule.exports.writeSync = NOT_IMPLEMENTED(\"writeSync\");\n","module.exports.parseStat = function parseStat(result) {\n  return {\n    dev: String(result.NSFileDeviceIdentifier),\n    // ino: 48064969, The file system specific \"Inode\" number for the file.\n    mode: result.NSFileType | result.NSFilePosixPermissions,\n    nlink: Number(result.NSFileReferenceCount),\n    uid: String(result.NSFileOwnerAccountID),\n    gid: String(result.NSFileGroupOwnerAccountID),\n    // rdev: 0, A numeric device identifier if the file is considered \"special\".\n    size: Number(result.NSFileSize),\n    // blksize: 4096, The file system block size for i/o operations.\n    // blocks: 8, The number of blocks allocated for this file.\n    atimeMs:\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    mtimeMs:\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    ctimeMs:\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    birthtimeMs:\n      Number(result.NSFileCreationDate.timeIntervalSince1970()) * 1000,\n    atime: new Date(\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ), // the 0.5 comes from the node source. Not sure why it's added but in doubt...\n    mtime: new Date(\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ),\n    ctime: new Date(\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ),\n    birthtime: new Date(\n      Number(result.NSFileCreationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ),\n    isBlockDevice: function() {\n      return result.NSFileType === NSFileTypeBlockSpecial;\n    },\n    isCharacterDevice: function() {\n      return result.NSFileType === NSFileTypeCharacterSpecial;\n    },\n    isDirectory: function() {\n      return result.NSFileType === NSFileTypeDirectory;\n    },\n    isFIFO: function() {\n      return false;\n    },\n    isFile: function() {\n      return result.NSFileType === NSFileTypeRegular;\n    },\n    isSocket: function() {\n      return result.NSFileType === NSFileTypeSocket;\n    },\n    isSymbolicLink: function() {\n      return result.NSFileType === NSFileTypeSymbolicLink;\n    }\n  };\n};\n\nvar ERRORS = {\n  EPERM: {\n    message: \"operation not permitted\",\n    errno: -1\n  },\n  ENOENT: {\n    message: \"no such file or directory\",\n    errno: -2\n  },\n  EACCES: {\n    message: \"permission denied\",\n    errno: -13\n  },\n  ENOTDIR: {\n    message: \"not a directory\",\n    errno: -20\n  },\n  EISDIR: {\n    message: \"illegal operation on a directory\",\n    errno: -21\n  }\n};\n\nfunction fsError(code, options) {\n  var error = new Error(\n    code +\n      \": \" +\n      ERRORS[code].message +\n      \", \" +\n      (options.syscall || \"\") +\n      (options.path ? \" '\" + options.path + \"'\" : \"\")\n  );\n\n  Object.keys(options).forEach(function(k) {\n    error[k] = options[k];\n  });\n\n  error.code = code;\n  error.errno = ERRORS[code].errno;\n\n  return error;\n}\n\nmodule.exports.fsError = fsError;\n\nmodule.exports.fsErrorForPath = function fsErrorForPath(\n  path,\n  shouldBeDir,\n  err,\n  syscall\n) {\n  var fileManager = NSFileManager.defaultManager();\n  var doesExist = fileManager.fileExistsAtPath(path);\n  if (!doesExist) {\n    return fsError(\"ENOENT\", {\n      path: path,\n      syscall: syscall || \"open\"\n    });\n  }\n  var isReadable = fileManager.isReadableFileAtPath(path);\n  if (!isReadable) {\n    return fsError(\"EACCES\", {\n      path: path,\n      syscall: syscall || \"open\"\n    });\n  }\n  if (typeof shouldBeDir !== \"undefined\") {\n    var isDirectory = module.exports.lstatSync(path).isDirectory();\n    if (isDirectory && !shouldBeDir) {\n      return fsError(\"EISDIR\", {\n        path: path,\n        syscall: syscall || \"read\"\n      });\n    } else if (!isDirectory && shouldBeDir) {\n      return fsError(\"ENOTDIR\", {\n        path: path,\n        syscall: syscall || \"read\"\n      });\n    }\n  }\n  return new Error(err || \"Unknown error while manipulating \" + path);\n};\n\nmodule.exports.encodingFromOptions = function encodingFromOptions(\n  options,\n  defaultValue\n) {\n  return options && options.encoding\n    ? String(options.encoding)\n    : options\n    ? String(options)\n    : defaultValue;\n};\n\nmodule.exports.NOT_IMPLEMENTED = function NOT_IMPLEMENTED(name) {\n  return function() {\n    throw new Error(\n      \"fs.\" +\n        name +\n        \" is not implemented yet. If you feel like implementing it, any contribution will be gladly accepted on https://github.com/skpm/fs\"\n    );\n  };\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar sketchSpecifics = require('./sketch-specifics')\n\n// we only expose the posix implementation since Sketch only runs on macOS\n\nvar CHAR_FORWARD_SLASH = 47\nvar CHAR_DOT = 46\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot) {\n  var res = ''\n  var lastSegmentLength = 0\n  var lastSlash = -1\n  var dots = 0\n  var code\n  for (var i = 0; i <= path.length; i += 1) {\n    if (i < path.length) code = path.charCodeAt(i)\n    else if (code === CHAR_FORWARD_SLASH) break\n    else code = CHAR_FORWARD_SLASH\n    if (code === CHAR_FORWARD_SLASH) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/')\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = ''\n                lastSegmentLength = 0\n              } else {\n                res = res.slice(0, lastSlashIndex)\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/')\n              }\n              lastSlash = i\n              dots = 0\n              continue\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = ''\n            lastSegmentLength = 0\n            lastSlash = i\n            dots = 0\n            continue\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += '/..'\n          else res = '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i)\n        else res = path.slice(lastSlash + 1, i)\n        lastSegmentLength = i - lastSlash - 1\n      }\n      lastSlash = i\n      dots = 0\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots\n    } else {\n      dots = -1\n    }\n  }\n  return res\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root\n  var base =\n    pathObject.base || (pathObject.name || '') + (pathObject.ext || '')\n  if (!dir) {\n    return base\n  }\n  if (dir === pathObject.root) {\n    return dir + base\n  }\n  return dir + sep + base\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = ''\n    var resolvedAbsolute = false\n    var cwd\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i -= 1) {\n      var path\n      if (i >= 0) {\n        path = arguments[i]\n      } else {\n        if (cwd === undefined) {\n          cwd = posix.dirname(sketchSpecifics.cwd())\n        }\n        path = cwd\n      }\n\n      path = sketchSpecifics.getString(path, 'path')\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue\n      }\n\n      resolvedPath = path + '/' + resolvedPath\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute)\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0) return '/' + resolvedPath\n      else return '/'\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath\n    } else {\n      return '.'\n    }\n  },\n\n  normalize: function normalize(path) {\n    path = sketchSpecifics.getString(path, 'path')\n\n    if (path.length === 0) return '.'\n\n    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n    var trailingSeparator =\n      path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH\n\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute)\n\n    if (path.length === 0 && !isAbsolute) path = '.'\n    if (path.length > 0 && trailingSeparator) path += '/'\n\n    if (isAbsolute) return '/' + path\n    return path\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    path = sketchSpecifics.getString(path, 'path')\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH\n  },\n\n  join: function join() {\n    if (arguments.length === 0) return '.'\n    var joined\n    for (var i = 0; i < arguments.length; i += 1) {\n      var arg = arguments[i]\n      arg = sketchSpecifics.getString(arg, 'path')\n      if (arg.length > 0) {\n        if (joined === undefined) joined = arg\n        else joined += '/' + arg\n      }\n    }\n    if (joined === undefined) return '.'\n    return posix.normalize(joined)\n  },\n\n  relative: function relative(from, to) {\n    from = sketchSpecifics.getString(from, 'from path')\n    to = sketchSpecifics.getString(to, 'to path')\n\n    if (from === to) return ''\n\n    from = posix.resolve(from)\n    to = posix.resolve(to)\n\n    if (from === to) return ''\n\n    // Trim any leading backslashes\n    var fromStart = 1\n    for (; fromStart < from.length; fromStart += 1) {\n      if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) break\n    }\n    var fromEnd = from.length\n    var fromLen = fromEnd - fromStart\n\n    // Trim any leading backslashes\n    var toStart = 1\n    for (; toStart < to.length; toStart += 1) {\n      if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) break\n    }\n    var toEnd = to.length\n    var toLen = toEnd - toStart\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen\n    var lastCommonSep = -1\n    var i = 0\n    for (; i <= length; i += 1) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1)\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i)\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0\n          }\n        }\n        break\n      }\n      var fromCode = from.charCodeAt(fromStart + i)\n      var toCode = to.charCodeAt(toStart + i)\n      if (fromCode !== toCode) break\n      else if (fromCode === CHAR_FORWARD_SLASH) lastCommonSep = i\n    }\n\n    var out = ''\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; i += 1) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (out.length === 0) out += '..'\n        else out += '/..'\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0) return out + to.slice(toStart + lastCommonSep)\n    else {\n      toStart += lastCommonSep\n      if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) toStart += 1\n      return to.slice(toStart)\n    }\n  },\n\n  toNamespacedPath: function toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path\n  },\n\n  dirname: function dirname(path) {\n    path = sketchSpecifics.getString(path, 'path')\n    if (path.length === 0) return '.'\n    var code = path.charCodeAt(0)\n    var hasRoot = code === CHAR_FORWARD_SLASH\n    var end = -1\n    var matchedSlash = true\n    for (var i = path.length - 1; i >= 1; i -= 1) {\n      code = path.charCodeAt(i)\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i\n          break\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.'\n    if (hasRoot && end === 1) return '//'\n    return path.slice(0, end)\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined)\n      ext = sketchSpecifics.getString(ext, 'ext')\n    path = sketchSpecifics.getString(path, 'path')\n\n    var start = 0\n    var end = -1\n    var matchedSlash = true\n    var i\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return ''\n      var extIdx = ext.length - 1\n      var firstNonSlashEnd = -1\n      for (i = path.length - 1; i >= 0; i -= 1) {\n        var code = path.charCodeAt(i)\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1\n            break\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false\n            firstNonSlashEnd = i + 1\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1\n              end = firstNonSlashEnd\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd\n      else if (end === -1) end = path.length\n      return path.slice(start, end)\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1\n            break\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false\n          end = i + 1\n        }\n      }\n\n      if (end === -1) return ''\n      return path.slice(start, end)\n    }\n  },\n\n  extname: function extname(path) {\n    path = sketchSpecifics.getString(path, 'path')\n    var startDot = -1\n    var startPart = 0\n    var end = -1\n    var matchedSlash = true\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i)\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1\n          break\n        }\n        continue\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false\n        end = i + 1\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i\n        else if (preDotState !== 1) preDotState = 1\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1\n      }\n    }\n\n    if (\n      startDot === -1 ||\n      end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n    ) {\n      return ''\n    }\n    return path.slice(startDot, end)\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new Error('pathObject should be an Object')\n    }\n    return _format('/', pathObject)\n  },\n\n  parse: function parse(path) {\n    path = sketchSpecifics.getString(path, 'path')\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' }\n    if (path.length === 0) return ret\n    var code = path.charCodeAt(0)\n    var isAbsolute = code === CHAR_FORWARD_SLASH\n    var start\n    if (isAbsolute) {\n      ret.root = '/'\n      start = 1\n    } else {\n      start = 0\n    }\n    var startDot = -1\n    var startPart = 0\n    var end = -1\n    var matchedSlash = true\n    var i = path.length - 1\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i)\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1\n          break\n        }\n        continue\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false\n        end = i + 1\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i\n        else if (preDotState !== 1) preDotState = 1\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1\n      }\n    }\n\n    if (\n      startDot === -1 ||\n      end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n    ) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path.slice(1, end)\n        else ret.base = ret.name = path.slice(startPart, end)\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot)\n        ret.base = path.slice(1, end)\n      } else {\n        ret.name = path.slice(startPart, startDot)\n        ret.base = path.slice(startPart, end)\n      }\n      ret.ext = path.slice(startDot, end)\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1)\n    else if (isAbsolute) ret.dir = '/'\n\n    return ret\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null,\n\n  resourcePath: sketchSpecifics.resourcePath,\n}\n\nmodule.exports = posix\nmodule.exports.posix = posix\n","var util = require('util')\n\nmodule.exports.getString = function getString(path, argumentName) {\n  if (!util.isString(path)) {\n    // let's make a special case for NSURL\n    if (util.getNativeClass(path) === 'NSURL') {\n      return String(path.path().copy())\n    }\n    throw new Error(argumentName + ' should be a string. Got ' + typeof path + ' instead.')\n  }\n  return String(path)\n}\n\nmodule.exports.cwd = function cwd() {\n  if (typeof __command !== 'undefined' && __command.script() && __command.script().URL()) {\n    return String(__command.script().URL().path().copy())\n  }\n  return String(MSPluginManager.defaultPluginURL().path().copy())\n}\n\nmodule.exports.resourcePath = function resourcePath(resourceName) {\n  if (typeof __command === 'undefined' || !__command.pluginBundle()) {\n    return undefined\n  }\n  var resource = __command.pluginBundle().urlForResourceNamed(resourceName)\n  if (!resource) {\n    return undefined\n  }\n  return String(resource.path())\n}\n","var sketch = require('sketch')\nvar Document = require('sketch/dom').Document\nvar document = Document.getSelectedDocument()\n\nconst fs = require('@skpm/fs');\nconst path = require('@skpm/path');\nconst home = require(\"os\").homedir();\nconst exportPath = `${home}/SketchJSON/`\n\n\nvar texts = []\nvar paints = []\nvar shadows = []\nvar blurs = []\nvar output = {}\n\nexport default function () {\n\n\n  /*\n  Sketch's document.getTextStyles() doesn't return all the info, and returns an MSArray\n  \n  Types:\n  0 layerStyles\n  1 textStyles\n  \n  Returns a JavaScript Array of styles\n  */\n  function getSharedStyles(type) {\n    var myStyles = []\n    if (sketch.version.sketch < 52) {\n      var styles = (type == 0) ? MSDocument.currentDocument().documentData().layerStyles().objects() : MSDocument.currentDocument().documentData().layerTextStyles().objects();\n    } else {\n      var styles = (type == 0) ? MSDocument.currentDocument().documentData().allLayerStyles() : MSDocument.currentDocument().documentData().allTextStyles();\n    }\n\n    var sortByName = NSSortDescriptor.sortDescriptorWithKey_ascending(\"name\", 1);\n    styles = styles.sortedArrayUsingDescriptors([sortByName]);\n    styles.forEach(style => {\n      myStyles.push(style)\n    })\n    return myStyles;\n  }\n\n\n  /* Get the primitive colours that form all the foundations */\n  var colourPalette = {}\n  var colourStyles = getSharedStyles(0).filter(style => style.name().includes('ExtendedPalette') || style.name().includes('Overlays') && !style.name().includes('border'))\n\n  colourStyles.forEach(style => {\n  var value\n  var name = style.name().split('/')[style.name().split('/').length -1]\n  let fills = style.style().fills()\n      if(!fills.length){\n      value = \"transparent\"\n      }else{\n          let fill = fills[0]\n          if(fill.fillType() == 0){\n              value = MSColorToRGBA(fill.color())\n              }else{\n                  value = parseGradient(fill.gradient())\n              }\n            }\n      colourPalette[name] = value\n  })\n\n  if (!fs.existsSync(exportPath)){\n    fs.mkdirSync(exportPath);\n}\n\n  try {\n    fs.writeFileSync(exportPath+'colour-palette.json', JSON.stringify(colourPalette,null,4));\n  } catch(err) {\n    // An error occurred\n    console.error(err);\n  }\n\n   /* Get the theme colours, where a option is given a decision */\n\n  //Filter out styles that aren't fills.\n  const regex = RegExp('(0[12345])', 'g')\n  var themeColours = getSharedStyles(0).filter(style => style.name().split('/')[0] && \n  !style.name().includes('border') &&\n  !style.name().includes('Shadows') &&\n  !style.name().includes('Images') && \n  !style.name().includes('ExtendedPalette'))\n\n  var  outputThemeColours = {}\n\n  themeColours.forEach(style => {\n    \n    let value\n    var name = style.name().split('/')[style.name().split('/').length -1]\n    let fills = style.style().fills()\n        if(!fills.length){\n        value = \"transparent\"\n        }else{\n            let fill = fills[0]\n            if(fill.fillType() == 0){\n                value = getPrimitiveFromColor(fill.color(),name)\n                }else{\n                    value = parseGradient(fill.gradient())\n                }\n              }\n              \n      outputThemeColours[name] = value || \"undefined for some fucking reason\"\n  })\n\n\n  try {\n    fs.writeFileSync(exportPath+'theme-colours.json', JSON.stringify(outputThemeColours,null,4));\n  } catch(err) {\n    // An error occurred\n    console.error(err);\n  }\n\n\n\n\n\n\n  function getPrimitiveFromColor(color,name){\n    let c = MSColorToRGBA(color)\n    let prim = getKeyByValue(colourPalette, c)\n    return prim\n  }\n\n\n\n  function getKeyByValue(object, value) {\n    return Object.keys(object).find(key => object[key] === value);\n  }\n\n\n\n\n  ///=====================\n\n  var textStyles = getSharedStyles(1)\n\n  /*\n  Optional - Filter so we only get left aligned text, and the base colour.\n  Figma's less explicit around type alignment and colour for styles.\n  Therefore we only need to extract the Font Family, Weight, Size, Line Height and Kerning\n  \n  We ignore text decoration in these cases. Underlining should be done at the designers discrepancy in the design outputs.\n  Italic / Oblique fonts are pulled through, this is a side-effect of getting the weight from the PostScript name. \n   \n  */\n  textStyles = textStyles.filter(style => style.name().includes('inkBase') && document.getSharedTextStyleWithID(style.objectID()).style.alignment == 'left')\n\n\n\n  textStyles.forEach(style => {\n\n    //Output object\n    let o = {}\n    o.type = \"TEXT\"\n\n    //The input style\n   let inp = document.getSharedTextStyleWithID(style.objectID()).style\n\n    //Extracting the name of the weight from the Postscript name, Figma expects this in title case with spaces.\n    let fontStyle = style.style().textStyle().fontPostscriptName().split('-')[1].replace(/([a-z0-9])([A-Z])/g, '$1 $2')\n\n\n\n    //Remove the ink name from the token name\n    let n = style.name().split('/')\n    n.pop()\n    o.name = n.join('/')\n\n    o.fontSize = inp.fontSize\n    o.fontName = {\n      family: inp.fontFamily,\n      style: fontStyle\n    }\n    o.lineHeight = {\n      unit: \"PIXELS\",\n      value: inp.lineHeight\n    }\n    o.letterSpacing = inp.kerning\n    o.paragraphSpacing = inp.paragraphSpacing\n\n\n    texts.push(o)\n  })\n\n\n\n\n\n  /*\n  Get the shadow styles\n  Sketch's API doesn't let us fetch the blend mode of a shadow.\n  But, there's no logical way to set the blend mode of a box-shadow in CSS, so we ignore and set it to 'NORMAL'\n  Figma doesn't allow for Spread on drop shadows. Something something GPU intensive blah blah.. \n  We include it here anyway commented out, because maybe one day in the future they'll enable it.\n  */\n  var shadowStyles = getSharedStyles(0).filter(style => style.name().includes('Shadows'))\n\n  shadowStyles.forEach(style => {\n    let o = {}\n    o.type = \"EFFECT\"\n    let inp = style.style()\n    o.name = `${style.name()}`\n    o.effects = []\n\n    inp.shadows().forEach(shadow => {\n     let  e = {}\n      e.type = \"DROP_SHADOW\"\n      e.color = {\n        r: shadow.color().red(),\n        g: shadow.color().green(),\n        b: shadow.color().blue(),\n        a: shadow.color().alpha()\n      }\n      e.blendMode = \"NORMAL\"\n      e.visible = true\n      e.offset = {\n        x: shadow.offsetX(),\n        y: shadow.offsetY()\n      }\n      e.radius = shadow.blurRadius()\n     // e.spread = shadow.spread()\n      o.effects.push(e)\n    })\n\n    \n    shadows.push(o)\n  })\n\n\n\n  /*\n  Blur effects, this isn't the best implementation.. NewsKit was built on top of Sketch's implementations,\n  Blurs aren't fully accounted for in NewsKit\n  Sketch Types\n  0 Gaussian (Figma Layer Blur)\n  1 Motion (Unsupported in Figma)\n  2 Zoom  (Unsuppoted in Figma)\n  3 Background\n  \n  */\n  var blurStyles = getSharedStyles(0).filter(style => style.style().blur().isEnabled() == 1 && !style.name().includes('border'))\n  blurStyles.forEach(style => {\n    let inp = style.style().blur()\n\n   let o = {}\n    o.type = \"EFFECT\"\n    //Need a better Naming System here...\n    o.name = 'Blur/' + style.name()\n    o.effects = []\n    let e = {}\n    switch (inp.type()) {\n      case 0:\n        e.type = \"LAYER_BLUR\"\n        break;\n      case 1:\n        console.warn('Motion Blurs are unsupported by Figma')\n        break;\n      case 2:\n        console.warn('Zoom Blurs are unsupported by Figma')\n        break;\n      case 3:\n        e.type = \"BACKGROUND_BLUR\"\n        break;\n    }\n    e.visible = true\n    e.radius = inp.radius()\n\n    //Saturation is not yet supported for background blurs in Figma..\n    //inp.saturation() ? e.saturation = inp.saturation() : null\n\n    o.effects.push(e)\n    blurs.push(o)\n  })\n\n\n  //Combine all the styles into one Object\n  output.texts = texts\n  output.paints = paints\n  output.blurs = blurs\n  output.shadows = shadows\n\n\n  const str = JSON.stringify(colourPalette,null,4)\n  //const str = JSON.stringify(output, null, 4)\n\n  //Make a dialog box to show the output\n  var UI = require('sketch/ui')\n  UI.getInputFromUser(\n    \"Style Output:\", {\n      description: \"Click ok to Export\",\n      initialValue: str,\n      type: UI.INPUT_TYPE.string,\n      numberOfLines: 20\n\n    },\n    (err, value) => {\n\n      if (err) {\n        // most likely the user canceled the input\n        return\n      }\n      if (value) {\n        //Export styles when they hit Ok\n\n      //   if (!fs.existsSync(exportPath)){\n      //     fs.mkdirSync(exportPath);\n      // }\n      \n      //   try {\n      //     fs.writeFileSync(exportPath+'export.json', str);\n      //   } catch(err) {\n      //     // An error occurred\n      //     console.error(err);\n      //   }\n        \n\n        // var pasteBoard = NSPasteboard.generalPasteboard()\n        // pasteBoard.declareTypes_owner(NSArray.arrayWithObject(NSPasteboardTypeString), nil)\n        // pasteBoard.setString_forType(str, NSPasteboardTypeString)\n        UI.message('Styles exported to: ' + exportPath)\n      }\n    }\n  )\n\n\n\n}\n\n\n\n\n\nfunction parseGradient(gradient) {\n\n  let angle = angleBetween(gradient.from(), gradient.to())\n  let type\n  //console.log(gradient)\n  switch (gradient.gradientType()){\n  case 0:\n  type = \"linear-gradient\"\n  break;\n  case 1:\n  type = \"radial-gradient\"\n  break;\n  case 2:\n  type = \"angular-gradient\"\n  break;\n  }\n  \n  let stops = gradient.stops()\n  let str = []\n  stops.forEach(stop => {\n              str.push(` ${MSColorToRGBA(stop.color())} ${(stop.position().toFixed(4)*100)}%`)\n          })\n\n  let output = `${type}(${angle}deg,${str.join(',')})`\n\n  return output\n}\n\nfunction MSColorToRGBA(c){\nreturn `rgba(${Math.round(c.red() * 255)}, ${Math.round(c.green() * 255)}, ${Math.round(c.blue() * 255)}, ${c.alpha()})`\n}\n\nfunction angleBetween(p1,p2){\nlet angleDeg = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;\nreturn Math.round(angleDeg)\n}","module.exports = require(\"buffer\");","module.exports = require(\"os\");","module.exports = require(\"sketch\");","module.exports = require(\"sketch/dom\");","module.exports = require(\"sketch/ui\");","module.exports = require(\"util\");"],"sourceRoot":""}